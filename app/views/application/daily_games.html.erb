<%= content_for :title, 'Loading games...' %>
<%= content_for :head do %>
  <style>
      .game {
          margin-right: 20px;
          display: inline-block;
          width: 600px;
          max-width: 90vw;

      }
      body {
          margin: 10px 20px;
      }
  </style>
<!--  <link rel="stylesheet" href="/css/lichess_pgn_viewer.css">-->
  <link id="piece-sprite" href="/piece-css/cburnett.css" rel="stylesheet">
  <link href="/css/lichess_site.css" rel="stylesheet">
  <link href="/css/lichess_theme_light.css" rel="stylesheet">
  <link href="/css/lichess_pgn_viewer.css" rel="stylesheet">
  <script type="module">
      import LichessPgnViewer from 'https://cdn.jsdelivr.net/npm/lichess-pgn-viewer@2.1.0/dist/lichess-pgn-viewer.min.js';

      const playerName = '<%= @username %>';
      let gameCount = null;

      async function fetchGames() {
          const response = await fetch(`https://api.chess.com/pub/player/${playerName}/games`);
          const data = await response.json();
          return data.games;
      }

      function filterMyTurnGames(games) {
          return games.filter(game => (game.turn === 'white' && game.white.includes(playerName)) || (game.turn === 'black' && game.black.includes(playerName)));
      }

      function sortGamesByMostRecentActivity(games) {
          return games.sort((a, b) => b.last_activity - a.last_activity);
      }

      function filterTheirTurnGames(games) {
          const myTurnGames = filterMyTurnGames(games)
          const myTurnUrls = myTurnGames.map((game) => game.url);
          return games.filter((game) => !myTurnUrls.includes(game.url));
      }

      function generateGameLinks(games, container) {
          if (games.length === 0) {
              container.innerHTML = 'None to display';
              return;
          }
          games.forEach(game => {
              const lastActivity = game.last_activity;
              const url = game.url;
              const existingGame = document.getElementById(url);
              if (existingGame) {
                  if (parseInt(existingGame.dataset.lastActivity) === lastActivity) {
                      return;
                  } else {
                      existingGame.parentNode.removeChild(existingGame);
                  }
              }
              const gameContainer = document.createElement('div');
              gameContainer.classList.add('game');
              gameContainer.id = game.url;
              gameContainer.dataset.lastActivity = lastActivity;
              const link = document.createElement('a');
              link.href = game.url;
              link.target = '_blank';

              const myColor = game.white.includes(playerName) ? 'white' : 'black';

              link.textContent = `chess.com`;

              const lineBreak = document.createElement('br');

              const board = document.createElement('div');
              board.classList.add('is2d');
              board.id = game.url;

              gameContainer.appendChild(link);
              gameContainer.appendChild(board);
              gameContainer.appendChild(lineBreak);
              container.appendChild(gameContainer);

              setTimeout(() => {
                  LichessPgnViewer(board, {
                      pgn: game.pgn,
                      initialPly: 'last',
                      orientation: myColor,
                      scrollToMove: false,
                  });
              });
          });
      }

      function updateGameCount(count) {
          if (gameCount === count) {
              return;
          }

          document.title = `${count} ${chessSymbols(count)}`;
      }

      function chessSymbols(count) {
          const pawn = '\u2658';
          return pawn.repeat(count);
      }

      async function updateGames() {
          const games = await fetchGames();
          const myTurnGames = filterMyTurnGames(games);
          updateGameCount(myTurnGames.length);
          const myTurnContainer = document.getElementById('gameLinks_myTurn')
          generateGameLinks(sortGamesByMostRecentActivity(myTurnGames), myTurnContainer);
          const theirTurnGames = filterTheirTurnGames(games);
          const theirTurnContainer = document.getElementById('gameLinks_theirTurn')
          generateGameLinks(sortGamesByMostRecentActivity(theirTurnGames), theirTurnContainer);
          setTimeout(updateGames, 5 * 1000);
      }

      document.addEventListener('DOMContentLoaded', async () => {
          await updateGames();
      });

      document.body.dataset.board = 'brown';
  </script>
<% end %>
<h1>Daily Games</h1>
<h2>My Turn</h2>
<div id="gameLinks_myTurn"></div>
<h2>Their Turn</h2>
<div id="gameLinks_theirTurn"></div>
